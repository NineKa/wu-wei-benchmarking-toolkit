#!/usr/bin/env node
var path = require('path')
var nopt = require('nopt')
var noptUsage = require('nopt-usage')
var shelljs = require('shelljs')
var fs = require('fs')
var configLib = require(path.join(__dirname, '../lib/config.js'))
var request = require('request')
var tar = require('tar')
var StreamZip = require('node-stream-zip')
var zlib = require('zlib')
var dir = require('node-dir')

function onError (e) {
  if (e.stack) {
    console.log(e.stack)
  }
  console.log(e)
  throw e
}

function whenVerbose (m) {
  if (options.verbose) {
    console.log(m)
  }
}

function barrier (promises) {
  function resolved (v) {
    return {'resolved': v}
  }

  function rejected (v) {
    return {'rejected': v}
  }

  return Promise
    .all(promises.map((p) => p.then(resolved, rejected)))
    .then((promises) => {
      return {
        resolved: promises
          .filter((o) => o.hasOwnProperty('resolved'))
          .map((o) => o.resolved),
        rejected: promises
          .filter((o) => o.hasOwnProperty('rejected'))
          .map((o) => o.rejected)
      }
    })
}

function parse (id) {
  whenVerbose('parse(' + id + ')')

  if (id.match('^git')) {
    return {
      type: 'git',
      value: id.replace('://', '@')
    }
  } else if (id.match('^(' +
      Object.keys(registry)
        .join('|') +
      ')')) {
    return {
      type: 'short-name',
      value: id
    }
  } else if (id.match('^http(s)?:')) {
    return {
      type: 'url',
      value: id
    }
  } else if (!fs.accessSync(id)) {
    var stat = fs.statSync(id)
    if (stat.isFile()) {
      return {
        type: 'file',
        value: id
      }
    } else if (stat.isDirectory()) {
      return {
        type: 'directory',
        value: id
      }
    } else {
      throw new Error('Invalid id ' + id)
    }
  } else {
    throw new Error('Invalid id ' + id)
  }
}

function extractArchive (filePath) {
  var dirPath = path.dirname(filePath)

  return new Promise(function (resolve, reject) {
    function done () {
      whenVerbose('Extracted archive ' + filePath + '\n to ' + dirPath)
      resolve(dirPath)
    }

    if (filePath.match('\.zip')) {
      var zip = new StreamZip({
        file: filePath
      })
        .on('error', reject)
        .on('ready', () => {
          zip.extract(null, dirPath, (err, count) => {
            if (err) {
              reject(err)
            } else {
              console.log('WARNING: executable permission are not set by the current zip extractor, you may need to set them manually')
              done()
            }
          })
        })
    } else if (filePath.match('\.tar')) {
      fs
        .createReadStream(filePath)
        .on('error', reject)
        .pipe(zlib.Unzip())
        .on('error', reject)
        .pipe(tar.Extract({ path: dirPath }))
        .on('error', reject)
        .on('end', done)
    } else {
      whenVerbose('Not a known archive, skipping extraction')
      resolve(dirPath)
    }
  })
}

function fetchFile (filePath, dest) {
  dest = dest || path.join(wuTmpDirPath, configLib.computeDirectoryName(filePath))
  var destPath = path.join(dest, path.basename(filePath))
  shelljs.mkdir('-p', dest)

  return new Promise(function (resolve, reject) {
    fs
      .createReadStream(filePath)
      .on('error', reject)
      .pipe(fs.createWriteStream(destPath))
      .on('close', () => {
        whenVerbose('Copied file from ' + filePath)
        extractArchive(destPath)
          .then(resolve, reject)
      })
      .on('error', reject)
  })
}

function fetchURL (url, dest) {
  dest = dest || path.join(wuTmpDirPath, configLib.computeDirectoryName(url))
  var destPath = path.join(dest, path.basename(url))
  shelljs.mkdir('-p', dest)

  return new Promise(function (resolve, reject) {
    var f = fs.createWriteStream(destPath)
    f.on('close', () => {
      whenVerbose('Downloaded file from url ' + url)
      extractArchive(destPath)
        .then(resolve, reject)
    })
    request(url, (err, res, body) => {
      if (err || !res || res.statusCode !== 200) {
        whenVerbose('fetchURL error ' + err)
        reject('Invalid url: ' + url)
      }
    }).pipe(f)
  })
}

function fetchGit (gitPath, dest) {
  dest = dest || path.join(wuTmpDirPath, configLib.computeDirectoryName(gitPath))
  shelljs.mkdir('-p', dest)
  return new Promise(function (resolve, reject) {
    shelljs
      .exec('cd ' + dest + ' && git clone --recursive ' + gitPath, {silent: true}, (code, stdout, stderr) => {
        if (code !== 0) {
          reject(stdout + (stderr || ''))
        } else {
          whenVerbose(stdout)
          whenVerbose('Downloaded git repository from ' + gitPath)
          resolve(dest)
        }
      })
  })
}

function fetchRemote (parsed) {
  if (!parsed.type) {
    return Promise.reject(new Error('Invalid parsed ' + parsed))
  }

  if (parsed.type === 'url') {
    console.log('Installing from url ' + parsed.value)
    return fetchURL(parsed.value)
  } else if (parsed.type === 'git') {
    console.log('Installing from git repository ' + parsed.value)
    return fetchGit(parsed.value)
  } else if (parsed.type === 'file') {
    console.log('Installing from file ' + parsed.value)
    return fetchFile(parsed.value)
  } else {
    return Promise.reject(new Error('Nothing to fetch for parsed.type ' + parsed.type))
  }
}

function getInstallable (tmpDir) {
  whenVerbose('getInstallable(' + tmpDir + ')')
  return new Promise(function (resolve, reject) {
    dir.paths(tmpDir, function (err, paths) {
      if (err) {
        reject(err)
      }
      var regex = '(benchmark|compiler|environment|implementation|suite)\.json'
      var descriptionPaths = paths.files.filter(f => f.match(regex))
      if (descriptionPaths.length === 0) {
        whenVerbose('No description file found in ' + tmpDir)
        return resolve({
          tmpDir: tmpDir,
          type: null,
          rootDir: tmpDir,
          destination: tmpDir,
          description: null
        })
      }

      // Find the description file closest to the installable root directory
      descriptionPaths.sort(function (a, b) {
        return a.length - b.length
      })

      Promise.all(descriptionPaths.map((descriptionPath) => {
        return configLib.validateDescription(descriptionPath)
          .then((description) => {
            whenVerbose('Description at ' + descriptionPath + ' is ')
            whenVerbose(description)
            return {
              tmpDir: tmpDir,
              type: description.type,
              rootDir: path.dirname(descriptionPath),
              destination: path.dirname(descriptionPath),
              description: description,
              otherInstallables: []
            }
          })
      })).catch(reject)
        .then((installables) => {
          var installable = installables[0]
          installable.destination = null
          installable.otherInstallables = installables.slice(1)
          resolve(installable)
        })
    })
  })
}

function fetchDescriptionDependencies (options) {
  return function (installable) {
    if (!installable.type) {
      return Promise.resolve(installable)
    }

    whenVerbose('fetchDescriptionDependencies(' + JSON.stringify(installable) + ')')
    // If the artifact description specifies explicit dependencies,
    // install them
    var description = installable.description
    if (description.hasOwnProperty('dependencies')) {
      return Promise.all(Object.keys(description.dependencies).map((destination) => {
        if (!configLib.isRelativePath(destination)) {
          return Promise.reject(new Error(
            'Invalid relative path ' + destination + ' in ' +
            description.type + ' ' +
            description['short-name'] +
            ' dependency '))
        }
        var id = description.dependencies[destination]
        return fetch(
          id,
          {
            destination: path.join(installable.rootDir, destination)
          })
      })).then((dependencies) => Promise.resolve(installable))
    } else {
      return Promise.resolve(installable)
    }
  }
}

function fetchBenchmarkImplementations (options) {
  return function (installable) {
    if (!installable.type) {
      return Promise.resolve(installable)
    }

    whenVerbose('fetchBenchmarkImplementations(' + JSON.stringify(installable) + ')')
    var description = installable.description
    // If the installable is a benchmark, recursively install the implementations
    if (description.type === 'benchmark') {
      if (description.hasOwnProperty('implementations')) {
        shelljs.mkdir('-p', path.join(installable.rootDir, 'implementations'))

        return Promise.all(Object.keys(description.implementations).map((shortName) => {
          if (!configLib.validateShortName(shortName)) {
            return Promise.reject(new Error(
              'Invalid implementation short-name ' + shortName +
              ' in benchmark ' + description['short-name']))
          }

          return fetch(
            description.implementations[shortName],
            { destination: path.join(installable.rootDir, 'implementations', shortName),
              'short-name': shortName
            })
        })).then(Promise.resolve(installable))
      } else {
        return Promise.resolve(installable)
      }
    } else {
      return Promise.resolve(installable)
    }
  }
}

function fetchSuiteDependencies (artifact, options) {
  var suite = artifact.description
  var artifacts = []
  var collections = [
    'benchmarks',
    'compilers',
    'environments',
    'suites'
  ]

  console.log('Fetching all artifacts from suite ' + artifact.description.name)
  collections.forEach((c) => {
    if (suite.hasOwnProperty(c)) {
      Object.keys(suite[c])
        .forEach((shortName) => {
          var id = suite[c][shortName]
          artifacts.push(
            fetch(id, { 'short-name': shortName })
              .catch((err) => {
                whenVerbose('Error when fetching dependency ' + shortName + ' from ' + id)
                return Promise.reject({id: id, shortName: shortName, msg: err})
              })
          )
        })
    }
  })

  return barrier(artifacts)
    .then((artifacts) => {
      artifacts.rejected.forEach((err) => {
        console.log('Fetching failed for artifact: ')
        console.log(err.id)
        console.log(err.msg)
        console.log()
      })

      return artifact
    })
}

function fetchOtherArtifacts (options) {
  return function (installable) {
    whenVerbose('fetchOtherArtifacts(' + JSON.stringify(installable) + ')')
    return Promise.all(installable.otherInstallables.map((installable) => {
      return fetch(installable.rootDir, options)
    })).then((installables) => {
      return installable
    })
  }
}

function fetchDependencies (options) {
  return function (installable) {
    whenVerbose('fetchDependencies(' + JSON.stringify(installable) + ')')
    if (!installable.type) {
      whenVerbose('Not a wu-wei artifact, skipping dependencies')
      return installable
    }

    if (installable.type === 'suite') {
      return fetchSuiteDependencies(installable, options)
        .then(validateArtifact(options))
    } else {
      return fetchBenchmarkImplementations(options)(installable)
        .then(fetchDescriptionDependencies(options))
        .then((installable) => {
          whenVerbose('fetchDependencies ' + JSON.stringify(installable))
          return getInstallable(installable.rootDir)
        })
        .then(fetchOtherArtifacts(options))
        .then(validateArtifact(options))
    }
  }
}

function validateArtifact (options) {
  return (artifact) => {
    whenVerbose('Checking whether the artifact is valid')
    artifact.description['short-name'] = options.shortName || artifact.description['short-name']
    return new Promise(function (resolve, reject) {
      var desc = artifact.description
      if (!desc['short-name']) {
        return reject('No short-name provided in artifact description')
      }

      var shortName = desc['short-name']
      if (shortName === undefined || !configLib.validateShortName(shortName)) {
        return reject('Invalid short-name ' + desc['short-name'])
      }

      fs.writeFile(
        path.join(artifact.rootDir, artifact.type + '.json'),
        JSON.stringify(desc, null, '  '),
        function (err) {
          if (err) {
            reject(err)
          } else {
            if (!artifact.destination) {
              var artifactCollectionDir = path.join(suiteRoot, artifact.type + 's')
              if (!shelljs.test('-e', artifactCollectionDir)) {
                shelljs.mkdir('-p', artifactCollectionDir)
              }

              artifact.destination = path.join(artifactCollectionDir, shortName)
            }

            if (shelljs.test('-e', artifact.destination)) {
              reject(new Error('Aborting: existing artifact in ' + artifact.destination))
            } else {
              whenVerbose('Artifact is ready to be moved')
              resolve(artifact)
            }
          }
        })
    })
  }
}

function move (installable) {
  return new Promise(function (resolve, reject) {
    if (!installable.rootDir) {
      return reject(new Error('Internal error: no root directory specified for ' + JSON.stringify(installable)))
    }

    if (!installable.destination) {
      return reject(new Error('No installation directory specified for ' + JSON.stringify(installable)))
    }

    if (installable.rootDir === installable.destination) {
      whenVerbose('Installable already in its final destination ' + JSON.stringify(installable))
      return resolve(installable)
    }

    if (shelljs.test('-e', installable.destination)) {
      return reject(new Error('Aborting: ' + installable.destination + ' already exists'))
    }

    whenVerbose('Moving ' + installable.rootDir + ' to ' + installable.destination)
    fs.rename(installable.rootDir, installable.destination, function (err) {
      if (err) {
        reject(err)
      } else {
        resolve(installable)
      }
    })
  })
}

function cleanupThenExit (exitCode) {
  return function (err) {
    if (err && err instanceof Error) {
      console.log(err.message)
    }

    whenVerbose('Cleaning up ' + wuTmpDirPath)

    // Safety check to prevent automatically deleting
    // the entire file system in case of programming error!
    if (wuTmpDirPath.match('\.wu')) {
      shelljs.rm('-rf', wuTmpDirPath)
    }

    process.exit(exitCode)
  }
}

function fetch (id, options) {
  whenVerbose('parse(' + id + '):')
  try {
    var parsed = parse(id)
  } catch (e) {
    return Promise.reject(new Error('Invalid artifact ' + id))
  }
  whenVerbose(parsed)

  if (parsed.type === 'url' ||
    parsed.type === 'git' ||
    parsed.type === 'file') {
    return fetchRemote(parsed)
      .then(getInstallable)
      .then(fetchDependencies(options))
      .then((installable) => {
        if (!installable.destination && options.destination) {
          installable.destination = options.destination
        } else if (!installable.destination && !options.destination) {
          return Promise.reject(new Error('No installation path specified for ' + parsed.value))
        }

        return Promise.resolve(installable)
          .then(move)
      })
  } else if (parsed.type === 'short-name') {
    return fetch(registry[parsed.value], options)
  } else if (parsed.type === 'directory') {
    var dirPath = path.resolve(process.cwd(), parsed.value)

    if (options.verbose || !parsed.value.match('.wu')) {
      console.log('Fetching dependencies in directory ' + parsed.value)
    }
    return getInstallable(dirPath)
      .then(fetchDependencies(options))
  } else {
    throw new Error('Invalid parse type ' + parsed.type)
  }
}

var suiteRoot = configLib.findRootDirectoryPath(process.cwd(), '.wu')
var wuTmpDirPath = path.join(suiteRoot, '.wu', 'tmp')

var registry = {
  'ostrich': 'https://raw.githubusercontent.com/Sable/ostrich-suite/master/suite.json',
  'backprop': '/Users/erick/Documents/Recherche/backprop-benchmark.zip',
  'c-commons': '/Users/erick/Documents/Recherche/ostrich-c-implementation-common.zip'
}

var knownOpts = {
  'help': Boolean,
  'root': String,
  'verbose': Boolean
}
var shortHands = {
  'h': ['--help'],
  'r': ['--root'],
  'v': ['--verbose']
}
var description = {
  'help': 'Display this help',
  'root': 'Benchmark suite root',
  'verbose': 'Display more information'
}
var parsed = nopt(knownOpts, shortHands, process.argv, 2)

if (parsed.help) {
  var usage = noptUsage(knownOpts, shortHands, description)
  var executableName = path.basename(process.argv[1])
  console.log('Usage: ' + executableName + ' [path] [options]')
  console.log(usage)
  process.exit(1)
}

var options = {
  verbose: parsed.verbose || false,
  'short-name': null
}

var id = parsed.argv.remain.length > 0 ? parsed.argv.remain[0] : process.cwd()
fetch(id, options)
  .catch(onError).catch(cleanupThenExit(1))
  .then(cleanupThenExit(0))

// Graceful shutdown in case of CTRL-C
if (process.platform === 'win32') {
  throw new Error('Unsupported windows platform')
/*
var rl = require('readline').createInterface({
  input: process.stdin,
  output: process.stdout
})

rl.on('SIGINT', function () {
  process.emit('SIGINT')
})
*/
}

process.on('SIGINT', function () {
  // temp.cleanupSync()
  cleanupThenExit(1)()
})
