#!/usr/bin/env node
var path = require('path')
var nopt = require('nopt')
var noptUsage = require('nopt-usage')
var shelljs = require('shelljs')
var fs = require('fs')
var configLib = require(path.join(__dirname, '../lib/config.js'))
var request = require('request')
var tar = require('tar')
var unzip = require('unzip')
var zlib = require('zlib')
var dir = require('node-dir')

function onError (e) {
  if (e.stack) {
    console.log(e.stack)
  }
  console.log(e)
  throw e
}

function whenVerbose (m) {
  if (options.verbose) {
    console.log(m)
  }
}

function barrier (promises) {
  function resolved (v) {
    return {'resolved': v}
  }

  function rejected (v) {
    return {'rejected': v}
  }

  return Promise
    .all(promises.map((p) => p.then(resolved, rejected)))
    .then((promises) => {
      return {
        resolved: promises
          .filter((o) => o.hasOwnProperty('resolved'))
          .map((o) => o.resolved),
        rejected: promises
          .filter((o) => o.hasOwnProperty('rejected'))
          .map((o) => o.rejected)
      }
    })
}

function parse (id) {
  whenVerbose('parse(' + id + ')')
  if (id.match('^git')) {
    return {
      type: 'git',
      value: id.replace('://', '@')
    }
  } else if (id.match('^(' +
      Object.keys(registry)
        .join('|') +
      ')')) {
    return {
      type: 'short-name',
      value: id
    }
  } else if (id.match('^http(s)?:')) {
    return {
      type: 'url',
      value: id
    }
  } else if (!fs.accessSync(id) && id.match('\.(tar|zip|gzip|gz)')) {
    return {
      type: 'file',
      value: id
    }
  } else {
    throw new Error('Invalid id ' + id)
  }
}

function extractArchive (filePath) {
  var dirPath = path.dirname(filePath)

  return new Promise(function (resolve, reject) {
    function done () {
      whenVerbose('Extracted archive ' + filePath + '\n to ' + dirPath)
      resolve(dirPath)
    }

    var input = fs
      .createReadStream(filePath)
      .on('error', reject)

    if (filePath.match('\.zip')) {
      input
        .pipe(unzip.Extract({ path: dirPath }))
        .on('error', reject)
        .on('close', done)
    } else if (filePath.match('\.tar')) {
      input
        .pipe(zlib.Unzip())
        .on('error', reject)
        .pipe(tar.Extract({ path: dirPath }))
        .on('error', reject)
        .on('end', done)
    } else {
      reject(new Error('No known archive extractor for file ' + filePath))
    }
  })
}

function fetchFileArchive (filePath, dest) {
  dest = dest || path.join(wuTmpDirPath, configLib.computeDirectoryName(filePath))
  var destPath = path.join(dest, path.basename(filePath))
  shelljs.mkdir('-p', dest)

  return new Promise(function (resolve, reject) {
    fs
      .createReadStream(filePath)
      .on('error', reject)
      .pipe(fs.createWriteStream(destPath))
      .on('close', () => {
        whenVerbose('Copied file from ' + filePath)
        extractArchive(destPath)
          .then(resolve, reject)
      })
      .on('error', reject)
  })
}

function fetchURL (url, dest) {
  dest = dest || path.join(wuTmpDirPath, configLib.computeDirectoryName(url))
  var destPath = path.join(dest, path.basename(url))
  shelljs.mkdir('-p', dest)

  return new Promise(function (resolve, reject) {
    var f = fs.createWriteStream(destPath)
    f.on('close', () => {
      whenVerbose('Downloaded file from url ' + url)
      extractArchive(destPath)
        .then(resolve, reject)
    })
    request(url, (err, res, body) => {
      if (err || res.statusCode !== 200) {
        whenVerbose('fetchURL error (statusCode: ' + res.statusCode + '): ' + err)
        reject(new Error('Invalid url (statusCode: ' + res.statusCode + '): ' + url))
      }
    }).pipe(f)
  })
}

function fetchGit (gitPath, dest) {
  dest = dest || path.join(wuTmpDirPath, configLib.computeDirectoryName(gitPath))
  shelljs.mkdir('-p', dest)
  return new Promise(function (resolve, reject) {
    shelljs
      .exec('cd ' + dest + ' && git clone ' + gitPath, {silent: true}, (code, stdout, stderr) => {
        if (code !== 0) {
          reject(stdout + (stderr || ''))
        } else {
          whenVerbose(stdout)
          whenVerbose('Downloaded git repository from ' + gitPath)
          resolve(dest)
        }
      })
  })
}

function fetch (id) {
  try {
    var parsed = parse(id)
  } catch (e) {
    return Promise.reject(new Error('Invalid artifact ' + id))
  }

  whenVerbose('fetch(' + id + '):')
  whenVerbose(parsed)
  if (parsed.type === 'file') {
    console.log('Installing artifact from file ' + parsed.value)
    return fetchFileArchive(parsed.value)
  } else if (parsed.type === 'url') {
    console.log('Installing artifact from url ' + parsed.value)
    return fetchURL(parsed.value)
  } else if (parsed.type === 'git') {
    console.log('Installing artifact from git repository ' + parsed.value)
    return fetchGit(parsed.value)
  } else if (parsed.type === 'short-name') {
    return fetch(registry[id])
  } else {
    throw new Error("Invalid parse type for id '" + parsed + "'")
  }
}

function getDescription (tmpDir) {
  return new Promise(function (resolve, reject) {
    dir.paths(tmpDir, function (err, paths) {
      if (err) {
        reject(err)
      }
      var regex = '(benchmark|compiler|environment|suite)\.json'
      var descriptions = paths.files.filter(f => f.match(regex))
      if (descriptions.length === 0) {
        reject(new Error('No description file found (<type>.json)'))
      }
      if (descriptions.length > 1) {
        reject(new Error('Artifact has more than one type: ' + descriptions.map(f => f.path)))
      }

      var type = descriptions[0].match(regex)[1]
      whenVerbose('Validating ' + type + '.json')
      return configLib.validateDescription(descriptions[0])
        .then((desc) => {
          resolve({
            tmpDir: tmpDir,
            type: type,
            rootDir: path.dirname(descriptions[0]),
            description: desc
          })
        })
        .catch(reject)
    })
  })
}

function installNodePackage (artifact) {
  return new Promise(function (resolve, reject) {
    whenVerbose('Installing npm dependencies:')
    shelljs.exec(
      'cd ' + artifact.rootDir + ' && npm install',
      {async: true, silent: true},
      function (code, stdout, stderr) {
        if (code !== 0) {
          reject(stderr)
        }
        whenVerbose(stdout)
        resolve(artifact)
      })
  })
}

function installCustom (artifact) {
  return new Promise(function (resolve, reject) {
    whenVerbose('Installing custom dependencies:')
    shelljs.exec(
      'cd ' + artifact.rootDir + ' && ./install',
      {async: true, silent: true},
      function (code, stdout, stderr) {
        if (code !== 0) {
          reject(stderr)
        }
        whenVerbose(stdout)
        resolve(artifact)
      })
  })
}

function installArtifact (artifact) {
  try {
    // If this is a node package, install dependencies
    var f = fs.statSync(path.join(artifact.rootDir, 'install'))
    if (f.isFile()) {
      return installCustom(artifact)
    } else {
      whenVerbose('Install script is not a file')
    }
  } catch (err) {
    whenVerbose('Skipping install script (no install script)')
  }

  try {
    // If this is a node package, install dependencies
    f = fs.statSync(path.join(artifact.rootDir, 'package.json'))
    if (f.isFile()) {
      return installNodePackage(artifact)
    }
    whenVerbose('package.json is not a file')
  } catch (err) {
    whenVerbose('Skipping installation of package.json dependencies (no package.json file)')
  }

  whenVerbose('Did not find installable dependencies')
  return artifact
}

function installSuite (artifact) {
  var suite = artifact.description
  var artifacts = []
  var collections = [
    'benchmarks',
    'compilers',
    'environments',
    'suites'
  ]

  console.log('Installing all artifacts from suite ' + artifact.description.name)
  collections.forEach((c) => {
    if (suite.hasOwnProperty(c)) {
      Object.keys(suite[c])
        .forEach((shortName) => {
          var id = suite[c][shortName]
          artifacts.push(
            fetch(id)
              .then(getDescription)
              .then(install)
              .catch((err) => {
                whenVerbose('Error when installing ' + shortName + ' from ' + id)
                err.id = id
                err.shortName = shortName
                return Promise.reject(err)
              })
          )
        })
    }
  })

  return barrier(artifacts)
    .then((artifacts) => {
      artifacts.rejected.forEach((err) => {
        console.log('Installation failed for artifact: ')
        console.log(err.id)
        console.log(err)
        console.log()
      })

      return artifacts.resolved
    })
}

function install (artifact) {
  if (artifact.type === 'suite') {
    return installSuite(artifact)
  } else {
    return installArtifact(artifact)
  }
}

function moveableArtifact (artifact) {
  whenVerbose('Checking whether the artifact is valid')
  artifact.description['short-name'] = options.shortName || artifact.description['short-name']
  return new Promise(function (resolve, reject) {
    var desc = artifact.description
    var shortName = desc['short-name']
    if (!configLib.validateShortName(shortName)) {
      reject('Invalid short-name ' + desc['short-name'])
    }

    fs.writeFile(
      path.join(artifact.rootDir, artifact.type + '.json'),
      JSON.stringify(desc, null, '  '),
      function (err) {
        if (err) {
          reject(err)
        } else {
          var artifactCollectionDir = path.join(suiteRoot, artifact.type + 's')
          if (!shelljs.test('-e', artifactCollectionDir)) {
            shelljs.mkdir('-p', artifactCollectionDir)
          }

          artifact.installDir = path.join(artifactCollectionDir, shortName)
          if (shelljs.test('-e', artifact.installDir)) {
            reject(new Error('Aborting: existing artifact in ' + artifact.installDir))
          } else {
            whenVerbose('Artifact is ready to be moved')
            resolve(artifact)
          }
        }
      })
  })
}

function moveArtifact (artifact) {
  return new Promise(function (resolve, reject) {
    whenVerbose('Moving artifact to ' + artifact.installDir)
    fs.rename(artifact.rootDir, artifact.installDir, function (err) {
      if (err) {
        reject(err)
      } else {
        resolve(artifact)
      }
    })
  })
}

function move (artifacts) {
  if (Array.prototype.isPrototypeOf(artifacts)) {
    return Promise.all(artifacts.map(moveableArtifact)).then((artifacts) => Promise.all(artifacts.map(moveArtifact)))
  } else {
    return moveableArtifact(artifacts).then(moveArtifact)
  }
}

function cleanupThenExit (exitCode) {
  return function (err) {
    if (err && err instanceof Error) {
      console.log(err.message)
    }

    whenVerbose('Cleaning up ' + wuTmpDirPath)

    // Safety check to prevent automatically deleting
    // the entire file system in case of programming error!
    if (wuTmpDirPath.match('\.wu')) {
      shelljs.rm('-rf', wuTmpDirPath)
    }

    process.exit(exitCode)
  }
}

var suiteRoot = configLib.findRootDirectoryPath(process.cwd(), '.wu')
var wuTmpDirPath = path.join(suiteRoot, '.wu', 'tmp')

var registry = {
  'ostrich:': 'git@github.com:Sable/ostrich-suite'
}

var knownOpts = {
  'help': Boolean,
  'root': String,
  'verbose': Boolean
}
var shortHands = {
  'h': ['--help'],
  'r': ['--root'],
  'v': ['--verbose']
}
var description = {
  'help': 'Display this help',
  'root': 'Benchmark suite root',
  'verbose': 'Display more information'
}
var parsed = nopt(knownOpts, shortHands, process.argv, 2)

if (parsed.help || parsed.argv.remain.length < 1) {
  var usage = noptUsage(knownOpts, shortHands, description)
  var executableName = path.basename(process.argv[1])
  console.log('Usage: ' + executableName + ' <path> [options]')
  console.log(usage)
  process.exit(1)
}

var options = {
  verbose: parsed.verbose || false,
  'short-name': null
}

fetch(parsed.argv.remain[0]).catch(cleanupThenExit(1))
  .then(getDescription)
  .then(install)
  .then(move)
  .catch(onError).catch(cleanupThenExit(1))
  .then(cleanupThenExit(0))

// Graceful shutdown in case of CTRL-C
if (process.platform === 'win32') {
  throw new Error('Unsupported windows platform')
/*
var rl = require('readline').createInterface({
  input: process.stdin,
  output: process.stdout
})

rl.on('SIGINT', function () {
  process.emit('SIGINT')
})
*/
}

process.on('SIGINT', function () {
  cleanupThenExit(1)()
})
