#!/usr/bin/env node
var path = require('path')
var nopt = require('nopt')
var noptUsage = require('nopt-usage')
var shelljs = require('shelljs')
var fs = require('fs')
var configLib = require(path.join(__dirname, '../lib/config.js'))
var request = require('request')
var tar = require('tar')
var unzip = require('unzip')
var zlib = require('zlib')
var dir = require('node-dir')

var registry = {
  'ostrich': 'https://github.com/Sable/ostrich-suite'
}

var options = {
  verbose: false,
  'short-name': null
}

function onError (e) {
  if (e.stack) {
    console.log(e.stack)
  }
  console.log(e)
}

function exit (code) {
  return function () {
    process.exit(code)
  }
}

function whenVerbose (m) {
  if (options.verbose) {
    console.log(m)
  }
}

function barrier (promises) {
  function resolved (v) {
    return {'resolved': v}
  }

  function rejected (v) {
    return {'rejected': v}
  }

  return Promise
    .all(promises.map((p) => p.then(resolved, rejected)))
    .then((promises) => {
      return {
        resolved: promises
          .filter((o) => o.hasOwnProperty('resolved'))
          .map((o) => o.resolved),
        rejected: promises
          .filter((o) => o.hasOwnProperty('rejected'))
          .map((o) => o.rejected)
      }
    })
}

function parse (id) {
  if (id.match('^git')) {
    return {
      type: 'git',
      value: id.replace('://', '@')
    }
  } else if (id.match('^(' +
      Object.keys(registry)
        .map(x => x + ':')
        .join('|') +
      ')')) {
    return {
      type: 'short-name',
      value: id
    }
  } else if (id.match('^http(s)?:')) {
    return {
      type: 'url',
      value: id
    }
  } else if (!fs.accessSync(id) && id.match('\.(tar|zip|gzip|bzip|gz|bz)')) {
    return {
      type: 'file',
      value: id
    }
  } else {
    return null
  }
}

var suiteRoot = configLib.findRootDirectoryPath(process.cwd(), '.wu')
var wuTmpDirPath = path.join(suiteRoot, '.wu', 'tmp')

function extractArchive (filePath) {
  var dirPath = path.dirname(filePath)
  return new Promise(function (resolve, reject) {
    var stream
    if (filePath.match('\.zip')) {
      stream = fs
        .createReadStream(filePath)
        .on('error', reject)
        .pipe(unzip.Extract({ path: dirPath }))
    } else if (filePath.match('\.tar')) {
      stream = fs
        .createReadStream(filePath)
        .on('error', reject)
        .pipe(zlib.Unzip())
        .pipe(tar.Extract({ path: dirPath }))
    } else {
      reject(new Error('No known archive extractor for file ' + filePath))
    }

    stream
      .on('error', reject)
      .on('end', () => {
        whenVerbose('Extracted archive ' + filePath + '\n to ' + dirPath)
        resolve(dirPath)
      })
  })
}

function fetchFileArchive (filePath, dest) {
  dest = dest || path.join(wuTmpDirPath, configLib.computeDirectoryName(filePath))
  var destPath = path.join(dest, path.basename(filePath))
  shelljs.mkdir('-p', dest)

  return new Promise(function (resolve, reject) {
    fs.createReadStream(filePath)
      .on('error', reject)
      .on('end', () => {
        whenVerbose('Copied file from ' + filePath)
        extractArchive(destPath)
          .then(resolve, reject)
      })
      .pipe(fs.createWriteStream(destPath))
  })
}

function fetchURL (url, dest) {
  dest = dest || path.join(wuTmpDirPath, configLib.computeDirectoryName(url))
  var destPath = path.join(dest, path.basename(url))
  shelljs.mkdir('-p', dest)

  return new Promise(function (resolve, reject) {
    request
      .get(url)
      .on('response', (res) => {
        if (res.statusCode !== 200) {
          onError('Invalid url (statusCode: ' + res.statusCode + '): ' + url)
        }
      })
      .on('error', reject)
      .on('end', () => {
        whenVerbose('Downloaded file from url ' + url)
        extractArchive(destPath)
          .then(resolve, reject)
      })
      .pipe(fs.createWriteStream(destPath))
  })
}

function fetchGit (gitPath, dest) {
  dest = dest || path.join(wuTmpDirPath, configLib.computeDirectoryName(gitPath))
  shelljs.mkdir('-p', dest)
  return new Promise(function (resolve, reject) {
    shelljs
      .exec('cd ' + dest + ' && git clone ' + gitPath, {silent: true}, (code, stdout, stderr) => {
        if (code !== 0) {
          reject(stdout + (stderr || ''))
        } else {
          whenVerbose(stdout)
          whenVerbose('Downloaded git repository from ' + gitPath)
          resolve(dest)
        }
      })
  })
}

function fetch (id) {
  var parsed = parse(id)
  if (parsed.type === 'file') {
    return fetchFileArchive(parsed.value)
  } else if (parsed.type === 'url') {
    return fetchURL(parsed.value)
  } else if (parsed.type === 'git') {
    return fetchGit(parsed.value)
  } else if (parsed.type === 'short-name') {
    return fetch(registry[parsed.value])
  } else {
    throw new Error("Invalid parse type for id '" + parsed + "'")
  }
}

function getDescription (tmpDir) {
  return new Promise(function (resolve, reject) {
    dir.paths(tmpDir, function (err, paths) {
      if (err) {
        reject(err)
      }
      var regex = '(benchmark|compiler|environment|suite)\.json'
      var descriptions = paths.files.filter(f => f.match(regex))
      if (descriptions.length === 0) {
        reject(new Error('No description file found (<type>.json)'))
      }
      if (descriptions.length > 1) {
        reject(new Error('Artifact has more than one type: ' + descriptions.map(f => f.path)))
      }

      var type = descriptions[0].match(regex)[1]
      whenVerbose('Validating ' + type + '.json')
      return configLib.validateDescription(descriptions[0])
        .then((desc) => {
          resolve({
            tmpDir: tmpDir,
            type: type,
            rootDir: path.dirname(descriptions[0]),
            description: desc
          })
        })
        .catch(reject)
    })
  })
}

function installNodePackage (artifact) {
  return new Promise(function (resolve, reject) {
    whenVerbose('Installing npm dependencies:')
    shelljs.exec(
      'cd ' + artifact.rootDir + ' && npm install',
      {async: true, silent: true},
      function (code, stdout, stderr) {
        if (code !== 0) {
          reject(stderr)
        }
        whenVerbose(stdout)
        resolve(artifact)
      })
  })
}

function installCustom (artifact) {
  return new Promise(function (resolve, reject) {
    whenVerbose('Installing custom dependencies:')
    shelljs.exec(
      'cd ' + artifact.rootDir + ' && ./install',
      {async: true, silent: true},
      function (code, stdout, stderr) {
        if (code !== 0) {
          reject(stderr)
        }
        whenVerbose(stdout)
        resolve(artifact)
      })
  })
}

function installArtifact (artifact) {
  try {
    // If this is a node package, install dependencies
    var f = fs.statSync(path.join(artifact.rootDir, 'install'))
    if (f.isFile()) {
      return installCustom(artifact)
    } else {
      whenVerbose('Install script is not a file')
    }
  } catch (err) {
    whenVerbose('Skipping install script (no install script)')
  }

  try {
    // If this is a node package, install dependencies
    f = fs.statSync(path.join(artifact.rootDir, 'package.json'))
    if (f.isFile()) {
      return installNodePackage(artifact)
    }
    whenVerbose('package.json is not a file')
  } catch (err) {
    whenVerbose('Skipping installation of package.json dependencies (no package.json file)')
  }

  whenVerbose('Did not find installable dependencies')
  return artifact
}

function installSuite (artifact) {
  var suite = artifact.description
  var artifacts = []
  var collections = [
    'benchmarks',
    'compilers',
    'environments',
    'suites'
  ]

  collections.forEach((c) => {
    if (suite.hasOwnProperty(c)) {
      Object.keys(suite[c])
        .forEach((shortName) => {
          var id = suite[c][shortName]
          artifacts.push(
            fetch(id)
              .then(getDescription)
              .then(install)
              .catch((err) => {
                err.id = id
                err.shortName = shortName
                return err
              }))
        })
    }
  })

  return barrier(artifacts)
    .then((artifacts) => {
      artifacts.rejected.forEach((err) => {
        console.log('Installation failed for artifact: ')
        console.log(err.id)
        console.log(err)
        console.log()
      })

      return artifacts.resolved
    })
}

function install (artifact) {
  if (artifact.type === 'suite') {
    return installSuite(artifact)
  } else {
    return installArtifact(artifact)
  }
}

function moveableArtifact (artifact) {
  whenVerbose('Checking whether the artifact is valid')
  artifact.description['short-name'] = options.shortName || artifact.description['short-name']
  return new Promise(function (resolve, reject) {
    var desc = artifact.description
    var shortName = desc['short-name']
    if (!configLib.validateShortName(shortName)) {
      reject('Invalid short-name ' + desc['short-name'])
    }

    fs.writeFile(
      path.join(artifact.rootDir, artifact.type + '.json'),
      JSON.stringify(desc, null, '  '),
      function (err) {
        if (err) {
          reject(err)
        }
        artifact.installDir = path.join(suiteRoot, artifact.type + 's', shortName)

        if (shelljs.test('-e', artifact.installDir)) {
          reject('Aborting: existing artifact in ' + artifact.installDir)
        } else {
          whenVerbose('Artifact is ready to be moved')
          resolve(artifact)
        }
      })
  })
}

function moveArtifact (artifact) {
  whenVerbose('Moving artifact to ' + artifact.installDir)
  shelljs.cp('-r', path.join(artifact.rootDir, '*'), artifact.installDir)
  return artifact
}

function move (artifacts) {
  if (Array.prototype.isPrototypeOf(artifacts)) {
    return Promise.all(artifacts.map(moveableArtifact)).then((artifacts) => Promise.all(artifacts.map(moveArtifact)))
  } else {
    return moveableArtifact(artifacts).then(moveArtifact)
  }
}

function cleanup (artifact) {
  return new Promise(function (resolve, reject) {
    whenVerbose('Cleaning up ' + wuTmpDirPath)

    // Safety check to prevent automatically deleting
    // the entire file system in case of programming error!
    if (wuTmpDirPath.match('\.wu')) {
      shelljs.rm('-rf', wuTmpDirPath)
    }
    resolve(artifact)
  })
}

// Resolve artifact source
// 1. File path
// 2. Url
// 3. Git repository
// 4. Registry short-name (expands to one of the others)

var id = process.argv[2]
console.log('Installing ' + id)
fetch(process.argv[2])
  .then(getDescription)
  .then(install)
  .then(move)
  .catch(onError)
  .then(cleanup)
  .then(exit(1))
